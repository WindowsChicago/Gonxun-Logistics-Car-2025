# generated by maixhub, tested on maixpy3 v0.4.8
# copy files to TF card and plug into board and power on
import sensor, image, lcd, time
import KPU as kpu
from machine import UART
import gc, sys
from fpioa_manager import fm
from board import board_info

fm.register(24, fm.fpioa.UART1_TX, force=True)    #TX映射到24引脚
fm.register(25, fm.fpioa.UART1_RX, force=True)    #RX映射到25引脚

#串口初始化
uart_A = UART(UART.UART1, baudrate=115200, bits=8, parity=None, stop=1, timeout=1000, read_buf_len=4096)

input_size = (224, 224)
labels = ['green', 'blue_r', 'green_r', 'red_r', 'blue', 'red']
anchors = [2.81, 2.72, 3.84, 3.63, 3.31, 3.28, 1.41, 1.97, 2.56, 2.56]

mode =21
rty = 0
rtx = 0
rfper = 0
gty =0
gtx = 0
gfper =0
bty =0
btx = 0
bfper =0
#串口信息发送函数
def sending_data(a,x,y,b,c):
        AXYBC = bytearray([a,x,y,b,c])
        uart_A.write(AXYBC)

def lcd_show_except(e):
    import uio
    err_str = uio.StringIO()
    sys.print_exception(e, err_str)
    err_str = err_str.getvalue()
    img = image.Image(size=input_size)
    img.draw_string(0, 10, err_str, scale=1, color=(0xff,0x00,0x00))
    lcd.display(img)

def init_uart():
    fm.register(10, fm.fpioa.UART1_TX, force=True)
    fm.register(11, fm.fpioa.UART1_RX, force=True)

    uart = UART(UART.UART1, 115200, 8, 0, 0, timeout=1000, read_buf_len=256)
    return uart

def main(anchors, labels = None, model_addr="/sd/m.kmodel", sensor_window=input_size, lcd_rotation=0, sensor_hmirror=False, sensor_vflip=False):
    sensor.reset()
    sensor.set_pixformat(sensor.RGB565)
    sensor.set_framesize(sensor.QVGA)
    sensor.skip_frames(time=2000)  # 跳过初始帧以稳定摄像头
    sensor.set_windowing(sensor_window)
    sensor.set_hmirror(sensor_hmirror)
    sensor.set_vflip(sensor_vflip)

    sensor.run(1)

    lcd.init(type=1)
    #lcd.rotation(lcd_rotation)
    lcd.clear(lcd.WHITE)
    lcd.rotation(3)




    try:
        img = image.Image("startup.jpg")
        lcd.display(img)
    except Exception:
        img = image.Image(size=(320, 240))
        img.draw_string(90, 110, "loading model...", color=(255, 255, 255), scale=2)
        lcd.display(img)

    #uart = init_uart()
    #comm = Comm(uart)

    try:
        task = None
        task = kpu.load(model_addr)
        kpu.init_yolo2(task, 0.5, 0.3, 5, anchors) # threshold:[0,1], nms_value: [0, 1]
        #mode = None # 初始化data为None或某个无效值
        while(True):
            #img = sensor.snapshot()
            t = time.ticks_ms()
            #从串口接收数据
           # modes = uart_A.read(6) #6字节，每个字节为16进制数据，串口发送端示例：5A 11(5A为检验包是否正确的校验码，包尾部数据无所谓，也可以填有效数据)
            #if modes!=None:           #去除干扰无用数组
            #    if modes[0]==0x5A:    #判断包头是否正确
            #        print(modes)
            #        mode=modes[1]
            #        mode= int(mode)


            img = sensor.snapshot()

            # 色块识别
            if mode == 21:  # 收到信号0x11，识别红色物块
                objects = kpu.run_yolo2(task, img)  # 识别物体
                if objects:
                    for obj in objects:
                        pos = obj.rect()
                        img.draw_rectangle(pos)
                        img.draw_string(pos[0], pos[1], "%s : %.2f" % (labels[obj.classid()], obj.value()), scale=2,color=(255, 0, 0))  # 检测识别物体是否是所训练的模型
                        x, y, width, height = obj.rect() #识别色块
                        if labels[obj.classid()] == 'red':  #labels 是保存色块色环标签的列表，当识别到绿色色块时
                            cx = x + width // 2  # 用识别物体矩形框中心点代替物体中心点
                            cy = y + height // 2

                            #x_offset = cx - 154
                            #y_offset = cy - 120
                            x_offset = cx
                            y_offset = cy

                            img.draw_cross(x_offset+42, y_offset+8, size=10)
                            print("red block (", x, ",", y, ")")
                            print("red block (", width, ",", height, ")")
                            #sending_data(0xBB, x_offset, y_offset)
                            img.draw_string(20, 2, ("%2d" % mode), color=(128, 0, 0), scale=3)
                            #break  # 找到目标后可以跳出循环以提高效率,避免一直在循环
                else:
                    #sending_data(0xAA, 0x00, 0x00);  # 未识别到反馈
                    print("未识别")

            if mode == 18:  # 收到信号0x12，识别绿色物块
                #print('green');
                objects = kpu.run_yolo2(task, img)  # 识别物体
                if objects:
                    for obj in objects:
                        pos = obj.rect()
                        #print(pos)
                        img.draw_rectangle(pos)
                        img.draw_string(pos[0], pos[1], "%s : %.2f" % (labels[obj.classid()], obj.value()), scale=2,color=(255, 0, 0))  # 检测识别物体是否是所训练的模型
                        x, y, width, height = obj.rect()

                        if labels[obj.classid()] == '18':  #labels 是保存色块色环标签的列表，当识别到绿色色块时
                            cx = x + width // 2  # 用识别物体矩形框中心点代替物体中心点
                            cy = y + height // 2
                            x_offset = cx - 154
                            y_offset = cy - 120
                            img.draw_cross(x_offset+42, y_offset+12, size=10)
                            print("green block (", x_offset, ",", y_offset, ")")
                            sending_data(0xBB, x_offset, y_offset);
                            img.draw_string(20, 2, ("%2d" % mode), color=(128, 0, 0), scale=3)
                            #if x_offset,x_offset == 0
                            #break  # 找到目标后可以跳出循环以提高效率,避免一直在循环
                else:
                    sending_data(0xAA, 0x00, 0x00);
                    print("未识别")

            if mode == 19:  # 收到信号0x13，识别绿色物块
                #print('blue');
                objects = kpu.run_yolo2(task, img)  # 识别物体
                if objects:
                    for obj in objects:
                        pos = obj.rect() #识别得到的是物体的(x, y, w, h)的元组，其中(x, y)是边界框左上角的坐标，w是宽度，h是高度。
                        #print(pos)
                        img.draw_rectangle(pos)
                        img.draw_string(pos[0], pos[1], "%s : %.2f" % (labels[obj.classid()], obj.value()), scale=2,color=(255, 0, 0))  # 检测识别物体是否是所训练的模型
                        x, y, width, height = obj.rect()
                        if labels[obj.classid()] == '19':  #labels 是保存色块色环标签的列表，当识别到蓝色色块时
                            cx = x + width // 2  # 用识别物体矩形框中心点代替物体中心点
                            cy = y + height // 2
                            x_offset = cx - 148
                            y_offset = cy - 120
                            img.draw_cross(x_offset+36, y_offset+8, size=10)
                            print("blue block (", x_offset, ",", y_offset, ")")
                            sending_data(0xBB, x_offset, y_offset);
                            img.draw_string(2, 2, ("%2d" % mode), color=(128, 0, 0), scale=3)
                            #break  # 找到目标后可以跳出循环以提高效率,避免一直在循环
                else:
                    sending_data(0xAA, 0x00, 0x00);
                    print("未识别")

                # 色环识别
            if mode == 33:
                objects = kpu.run_yolo2(task, img)  # 识别物体
                if objects:
                    for obj in objects:
                        pos = obj.rect()
                        #print(pos)
                        img.draw_rectangle(pos)
                        img.draw_string(pos[0], pos[1], "%s : %.2f" % (labels[obj.classid()], obj.value()), scale=2,color=(255, 0, 0))  # 检测识别物体是否是所训练的模型
                        x, y, width, height = obj.rect()
                        cx = x + width // 2  # 用识别物体矩形框中心点代替物体中心点
                        cy = y + height // 2
                        x_offset = cx - 112 #随便给的
                        y_offset = cy - 112
                        if labels[obj.classid()] == 'red_r':  #labels 是保存色块色环标签的列表，当识别到绿色色块时
                            img.draw_cross(x_offset+42, y_offset+8, size=10)
                            #print("red H (", x_offset, ",", y_offset, ")")
                            sending_data(0xBB, x_offset, y_offset);
                            img.draw_string(20, 2, ("%2d" % mode), color=(128, 0, 0), scale=3)
                            #break  # 找到目标后可以跳出循环以提高效率,避免一直在循环
                else:
                    sending_data(0xAA, 0x00, 0x00)
                    print("未识别")

            if mode == 34:  # 收到信号0x22，识别色环
                objects = kpu.run_yolo2(task, img)  # 识别物体
                if objects:
                    for obj in objects:
                        pos = obj.rect()  # 获取对象边界框
                        print(pos)
                        img.draw_rectangle(pos)
                        img.draw_string(pos[0], pos[1], "%s : %.2f" % (labels[obj.classid()], obj.value()), scale=2,color=(255, 0, 0))
                        x, y, width, height = obj.rect()
                        cx = x + width // 2  # 用识别物体矩形框中心点代替物体中心点
                        cy = y + height // 2
                        x_offset = cx - 154 #随便给的
                        y_offset = cy - 120
                        if labels[obj.classid()] == 'green_r':  #labels 是保存色块色环标签的列表，当识别到绿色色块时
                            img.draw_cross(x_offset+42, y_offset+8, size=10)  # 绘制十字线
                            #print("green H (", x_offset, ",", y_offset, ")")
                            sending_data(0xBB, x_offset, y_offset)  # 发送数据
                            img.draw_string(20, 2, ("%2d" % mode), color=(128, 0, 0), scale=3)
                            #break  # 找到目标后跳出循环
                else:
                    sending_data(0xAA, 0x00, 0x00)  # 未识别到反馈
                    print("未识别")

            if mode == 35:  # 收到信号0x23，识别蓝色色环
                # print('blue H');
                objects = kpu.run_yolo2(task, img)  # 识别物体
                if objects:
                    for obj in objects:
                        pos = obj.rect()
                        #print(pos)
                        img.draw_rectangle(pos)
                        img.draw_string(pos[0], pos[1], "%s : %.2f" % (labels[obj.classid()], obj.value()), scale=2,color=(255, 0, 0))  # 检测识别物体是否是所训练的模型
                        x, y, width, height = obj.rect()
                        cx = x + width // 2  # 用识别物体矩形框中心点代替物体中心点
                        cy = y + height // 2
                        x_offset = cx - 154 #随便给的
                        y_offset = cy - 120

                        if labels[obj.classid()] == 'blue_r':  #labels 是保存色块色环标签的列表，当识别到绿色色块时
                            img.draw_cross(x_offset+42, y_offset+8, size=10)
                            #print("blue H (", x_offset, ",", y_offset, ")")
                            sending_data(0xBB, x_offset, y_offset)
                            img.draw_string(20, 2, ("%2d" % mode), color=(128, 0, 0), scale=3)
                            #break  # 找到目标后可以跳出循环以提高效率,避免一直在循环
                else:
                    sending_data(0xAA, 0x00, 0x00)
                    print("未识别")
                # 显示图像
            lcd.display(img)

    except Exception as e:
        sys.print_exception(e)
        lcd_show_except(e)
    finally:
        if not task is None:
            kpu.deinit(task)


if __name__ == "__main__":
    try:
        # main(anchors = anchors, labels=labels, model_addr=0x300000, lcd_rotation=0)
        main(anchors = anchors, labels=labels, model_addr="/sd/model-164102.kmodel")
    except Exception as e:
        sys.print_exception(e)
        lcd_show_except(e)
    finally:
        gc.collect()
